<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Iker Galardi</title>
    <link>https://ikergalardi.github.io/post/</link>
    <description>Recent content in Posts on Iker Galardi</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 04 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ikergalardi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Data or object oriented? That is the question</title>
      <link>https://ikergalardi.github.io/post/2022-11-16-data-object-oriented-game/</link>
      <pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ikergalardi.github.io/post/2022-11-16-data-object-oriented-game/</guid>
      <description>Let me tell you the story of how object oriented programming is not always the way to go. Unless you studied computer science on the 90s, every school, university or bootcamp tries to convince students that object oriented programming is THE BEST and how functional or procedural programming is for old people (I certainly felt that at university).
Well oh well, data oriented programming is the new kid in town, so what gives?</description>
    </item>
    
    <item>
      <title>How not to write performant code</title>
      <link>https://ikergalardi.github.io/post/2022-09-26-how-not-to-write-performant-code/</link>
      <pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ikergalardi.github.io/post/2022-09-26-how-not-to-write-performant-code/</guid>
      <description>Don&amp;rsquo;t you feel like malloc is really slow? Most probably not, as the malloc implementation shipped on most standard libraries are probably older than me. Still, a fool past of myself thought that I could in 3 moths achieve what glibc achieved in most certainly triple the time. This is the story of how I ended up writing a memory allocator for my end of degree project for university.
For the last 5 moths I have been writting a hybrid memory allocator using the SLAB allocator used on most operating system kernels and what the operating system provides in order to accelerate memory allocations.</description>
    </item>
    
    <item>
      <title>Thoughts on the linux desktop</title>
      <link>https://ikergalardi.github.io/post/2022-03-08-thought-about-the-linux-desktop/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ikergalardi.github.io/post/2022-03-08-thought-about-the-linux-desktop/</guid>
      <description>Thoughts on the linux desktop Due to some hardware changes on my setup I’ve realized some issues regarding the current situation with the linux desktop (and distributions in general). So with this article I’ll try to explain my thoughts and propose some changes. Normal desktop usage
Let’s start analyzing the whole windowing stack… xorg or wayland? Wayland, being new in the neighborhood has a more modern and secure approach, but stability is lost due to new “untested” code being written.</description>
    </item>
    
    <item>
      <title>Rendering adventures</title>
      <link>https://ikergalardi.github.io/post/2021-11-30-rendering-adventures/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ikergalardi.github.io/post/2021-11-30-rendering-adventures/</guid>
      <description>Rendering adventures I’ve always been amazed with computer graphics, and looking at recent advancements with ray tracing, and the great upgrade that Unreal Engine 4 supposed over Unreal Engine 3 with the physically based rendering (PBR from now on) work flow made me more curious.
I had tried before GPU accelerated rendering with OpenGL, but I had never advanced more than a textured quad, so 2021’s summer was the time to finally tackle this curiosity with a own built PBR renderer written in C++ and vulkan.</description>
    </item>
    
    <item>
      <title>Journey to first completed project</title>
      <link>https://ikergalardi.github.io/post/2021-11-04-journey-to-first-completed-project/</link>
      <pubDate>Thu, 04 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ikergalardi.github.io/post/2021-11-04-journey-to-first-completed-project/</guid>
      <description>Journey to first completed project With this article I will describe the journey of creating an application to create other applications… kinda crazy right! It really isn’t. What LMake is resembles more to what GNU Make is than to what a compiler is.
The project started with another project, an operating system! Not many people have tried to build operating systems but those who did try know that the building and linking process differs a bit from standard applications.</description>
    </item>
    
  </channel>
</rss>
